"""
A library for Event-Driven Web Applications (EDWA).

EDWA is appropriate for applications that are similar to traditional desktop applications, in that
they need to maintain state for a particular user, but are not focused on sharing that state with others.
It is particularly useful when navigation between "pages" or "states" is dynamic and stack-like,
and/or when links are expected to carry out UI "actions".

A typical example might be a web store: from a product page, you click a link to add it to the shopping cart.
(That link does not have the typical "display some information" sematics of a normal HTTP GET,
but rather the "change my internal state" sematics of HTTP POST -- but it's implemented via GET.)
From the shopping cart, you enter a "subroutine" to change your (stored) shipping preferences.
Then you "pop" back up to the shopping cart, and click a link that causes your shipping charges to be recalculated.
Finally, you pop up again to the product page you started from.
EDWA is particularly focused on this kind of call/return and action/response navigation logic.

The current "call stack" is stored directly as a signed, base64-encoded URL where possible.
These links can be bookmarked and even emailed to others (although they may be quite long),
and will always preserve immutably their starting state, even if re-visited many times.
(Although this data is opaque, it could be decoded and inspected by a savvy client.
One could add (symmetric) encryption to prevent this.)
If the associated data grows too large, it is transparently substituted for a unique ID,
and the data itself is stored in the EDWA object.
(That object must then be persisted somehow, such as in the "session" object provided by your web framework.
Since retrieval then depends on the session ID, usually stored in a cookie, these cannot be emailed.)

Unlike my earlier efforts, this framework does not break the browser back button,
nor does it prevent the user from "forking" the application by opening a new tab or window.
However, if page contexts become large, the total size of the EDWA object may grow without bound.
If the total size exceeds a user-defined limit, "old" actions (not generated by the current view)
will be flushed away, which may break the back button and/or "forked" versions of the app.
Unfortunately, that's about the best I can do.

By convention, each "major state" or "page" of the application is represented as a class with a render() function.
Actions associated with that page are additional member functions.
The class is only used as a convenient grouping namespace: it must have a no-argument constructor,
and there is no guarantee that render() and the action function(s) will be called on the same instance.
Thus, if you prefer, all view AND actions may simply be top-level functions in one or more modules.

Views (e.g. render()) take two arguments, the current EDWA object and a "request" object from e.g. the web framework.
The EDWA object contains a "context" dictionary that is analogous to kwargs in a typical Python function.
Views should be "pure" -- they should not modify their context, although this is not enforced.
To protect against accidental misuse of the library, view are prohibited from calling do_goto/call/return().
They can create links to actions, however, using make_action().
Shortcuts are provided for *links* that navigate to other views: make_goto(), make_call(), and make_return().
For a link that simply re-displays the current view, call make_noop().

Actions also take two arguments, the current EDWA object and the web framework "request" object.
Actions may use EDWA.context to add/change/remove context variables for the current view,
or may change the current view using do_goto(), do_call(), or do_return().

Although I've tried to make this as efficient as possible, generating a simple action link takes ~300 us,
or about 20 times longer than just pickling and 5 times longer than pickling and compressing.
Most of this appears to be the HMAC signature, which protects the URLs from tampering.
In situations where server performance is an issue, this library is only appropriate if the back-end
processing of actions is significantly more costly than the overhead generated by EDWA.
(Probably true in most cases.  But your mileage may vary.)
On the other hand, if everything can be encoded as a URL, it may eliminate the need for a round-trip to the database.

=== SECURITY ===

There are several known possible dangers in using EDWA to develop a web applications, listed below.
Many of these are shared by some or all other web frameworks, but some may be unique to EDWA.
Other risks, unforeseen by the author, may also exist.

1.  Remote code execution / compromise of server machine
    EDWA uses Python's "pickle" module to store and retrieve objects.
    The "pickle" documentation states that it is not intended to be secure against malicious data.
    EDWA uses cryptographic signing to prevent clients from crafting malicious data to send to "pickle",
    but if (1) the secret key became known to the client, (2) the signing scheme were implemented incorrectly in EDWA,
    or (3) a weakness was discovered in HMAC-SHA1 signing, a client might circumvent this protection.
    Depending on the specific weaknesses of "pickle" and/or "cPickle", this could lead to buffer-overflow and other attacks.
    For this reason, it is *very* important to protect the secret key when storing pickled data
    in web pages or URLs on the client side (i.e. the GET and POST backends).

2.  Exposing private internal data to users
    In GET and POST mode, the current state of the application is stored on the client as page contents and/or URLs.
    Although this data is signed to prevent *modification*, by default the client can still *read* all the data stored there.
    If your application stores information in EDWA that you would not want the user to view,
    you must either encrypt the data (using the KeyczarEDWA object) or use the database backend.

3.  Session hijacking / user data theft
    The GET and database backends both store application state in the URL:  GET stores a pickled Python object directly,
    and the database stores a unique identifier in the URL which corresponds to an object stored in the database.
    This can be a feature, because application states can be bookmarked in the browser or emailed to oneself or others.
    However, these URLs may also be exposed to other web sites by the HTTP Referrer: header
    when the user leaves the application, e.g. by clicking a link to another site.
    In this case, a malicious third-party site could access the user's data directly (by decoding the GET pickle, as above)
    and/or hijack the user's session to mis-use the web application or steal user data from it.
    The harm (or not) of such attacks depends entirely on the nature of your web application.
    To protect against direct decoding, either encrypt the GET pickles with Keyczar, or use the database backend.
    To protect against hijacking, create a unique secret key for each user that is tied to the user's session cookie.
    (This will prevent users from emailing links to application states,
    and depending on the life of the session cookie, may prevent them from bookmarking application states.)
    Because Keyczar does not seem to support salting its on-disk keys,
    the GET backend cannot be protected against both these dangers simultanously.
    If this is a concern but you still want to use the GET backend, you should encrypt with Keyczar and then
    make sure all links to external sites pass through a "bounce" page on your server, e.g.:
    
        http://my-web-app.com/bounce?dest=http://evil-other-site.com/

    If implemented correctly, this should avoid passing GET pickle outside your site in the Referrer: header.
    Use a tool like Firebug to ensure that you have successfully done this.

=== CHOICE OF BACKEND ===

EDWA supports similar feature sets using several different backend implementations.
The available backends are GET, POST, and database;  the GET and POST modes also have encrypted variants.
Furthermore, for unencrypted GET and POST, you may use a global secret key or a per-user secret key for signing.
Note that all GET methods failover to their corresponding POST methods if encoded data size exceeds ~2000 characters.

- Unencrypted GET, same secret key for all users
  Pros: no database required, all data stored client-side, users can bookmark and email application states as links,
        users can "fork" the application by opening links in new tabs/windows.
  Cons: data size must stay below 2000 bytes when signed and encoded, data may be inspected by user,
        care must be taken to avoid exposing URLs to external web sites via the Referrer: header,
        requires basic JavaScript capabilities on the client (excludes web crawlers, etc).

- Unencrypted GET, unique secret key tied to user's session cookie
  Pros: no database required, all data stored client-side, users can bookmark application states
        (for the life of the cookie only), users can "fork" the application by opening links in new tabs/windows.
  Cons: data size must stay below 2000 bytes when signed and encoded, data may be inspected by user,
        care must be taken to avoid exposing URLs to external web sites via the Referrer: header (due to decoding, not hijacking),
        requires basic JavaScript capabilities on the client (excludes web crawlers, etc),
        user cannot email application states as links (and bookmarks will eventually expire)

- Encrypted GET, same secret key for all users (unique keys not supported by Keyczar)
  Pros: no database required, all data stored client-side, users can bookmark and email application states as links,
        users can "fork" the application by opening links in new tabs/windows, user cannot decode application data.
  Cons: data size must stay below 2000 bytes when signed and encoded,
        encrypting many links can be quite CPU intensive (~100 / second?),
        care must be taken to avoid exposing URLs to external web sites via the Referrer: header,
        requires basic JavaScript capabilities on the client (excludes web crawlers, etc).

- Unencrypted POST, same secret key for all users OR unique secret key tied to user's session cookie
  Pros: no database required, all data stored client-side, data size limited only by network bandwidth,
        no danger in exposing URLs to external web sites via the Referrer: header.
  Cons: data may be inspected by user, users cannot bookmark and email application states as links,
        users cannot "fork" the application by opening links in new tabs/windows,
        requires basic JavaScript capabilities on the client (excludes web crawlers, etc).

- Encrypted POST, same secret key for all users (unique keys not supported by Keyczar)
  Pros: no database required, all data stored client-side, data size limited only by network bandwidth,
        no danger in exposing URLs to external web sites via the Referrer: header, user cannot decode application data.
  Cons: users cannot bookmark and email application states as links,
        users cannot "fork" the application by opening links in new tabs/windows,
        encrypting many links can be quite CPU intensive (~100 / second?),
        requires basic JavaScript capabilities on the client (excludes web crawlers, etc).

- Database, same secret key (user GUID) for all users
  Pros: data size not limited by network bandwidth, user cannot decode application data,
        users can bookmark and email application states as links,
        users can "fork" the application by opening links in new tabs/windows,
        no JavaScript required on the client (permits web crawlers, etc).
  Cons: database required, data accumulates on server side and must be periodically purged,
        care must be taken to avoid exposing URLs to external web sites via the Referrer: header.

- Database, unique secret key (user GUID) tied to user's session cookie
  Pros: data size not limited by network bandwidth, user cannot decode application data,
        users can bookmark application states (for the life of the cookie only),
        users can "fork" the application by opening links in new tabs/windows,
        no danger in exposing URLs to external web sites via the Referrer: header,
        no JavaScript required on the client (permits web crawlers, etc).
  Cons: database required, data accumulates on server side and must be periodically purged,
        user cannot email application states as links (and bookmarks will eventually expire).
"""
import base64, hashlib, hmac, sys, zlib
import cPickle as pickle

def _dump_func(f):
    """Given a module-level or instance function, convert to a picklable form."""
    if hasattr(f, "im_class"): return ".".join((f.__module__, f.im_class.__name__, f.__name__))
    else: return ".".join((f.__module__, f.__name__))

def _load_func(x):
    """Restore a usable function from the results of _dump_func()."""
    names = x.split(".")
    # Try first 1, 2, ... names as the module name.
    # (Is it possible to import "foo.bar" without also importing "foo"?)
    module = None
    for ii in xrange(len(names)):
        module = sys.modules.get(".".join(names[:ii+1]))
        if module is not None: break
    else: assert False, "Could not find module for '%s'" % x
    # Add on remaining names to the module name.
    # Convert classes into instances of those classes.
    target = module
    for name in names[ii+1:]:
        target = getattr(target, name)
        if isinstance(target, type): target = target() # call zero-arg constructor on classes
    return target

class TamperingError(ValueError):
    pass

class EDWA(object):
    """The main point of interaction for clients.
    Don't try to pickle these objects between requests;
    just save the secret_key and create a new instance next time.
    Generated action IDs (passed in URLs) are typically 100 - 200 characters long.
    """
    PAGE_KEY = "__libedwa__.page_id"
    ACTION_KEY = "__libedwa__.action_id"
    MODE_RENDER = ['render'] # just a unique object instance, use "is"
    MODE_ACTION = ['action'] # just a unique object instance, use "is"
    def __init__(self, secret_key, use_GET=False):
        assert secret_key, "Must provide a non-empty secret key!"
        # Configuration
        self._secret_key = secret_key # protects actions stored in URLs
        self._use_GET = use_GET # use GET (data in URLs) or POST (no data in URLs)?
        self._max_url_length = 1900 # Internet Explorer is limited to URLs of 2048 characters TOTAL.
        # Record keeping
        self._mode = None # None, MODE_RENDER, MODE_ACTION
        self._curr_page = None
        self._curr_page_encoded = None
    @property
    def context(self):
        """The context object for the currently active page view."""
        return self._curr_page.context
    def _set_page(self, page):
        """Set the current page to some newly-created Page object."""
        assert self._mode is not EDWA.MODE_RENDER, "Can't change location during rendering!  Did you mean to call make_*()?"
        assert page is not None
        self._curr_page = page
        self._curr_page_encoded = None
    def _encode_page(self):
        assert self._curr_page is not None
        self._curr_page_encoded = base64.urlsafe_b64encode(zlib.compress(pickle.dumps(self._curr_page, pickle.HIGHEST_PROTOCOL), 1))
    def _decode_page(self):
        """In this implementation, the page data itself is not signed; it's signed in combination with an action.
        So you want to make sure the action has been verified before decoding the page, or it opens you to attacks against pickle."""
        assert self._curr_page_encoded is not None
        self._set_page(pickle.loads(zlib.decompress(base64.urlsafe_b64decode(self._curr_page_encoded))))
    def _encode_action(self, action):
        """Encode the Action directly as a URL.  Must be paired with page data when passed to run()."""
        assert self._mode is not EDWA.MODE_ACTION, "Can't create new actions during an action, because page state is not finalized."
        assert self._curr_page_encoded is not None, "Page state must be serialized before creating an action!"
        data = base64.urlsafe_b64encode(zlib.compress(pickle.dumps(action, pickle.HIGHEST_PROTOCOL), 1))
        auth = hmac.new(self._secret_key, "%s.%s" % (data, self._curr_page_encoded), hashlib.sha1).digest()
        return "%s.%s" % (base64.urlsafe_b64encode(auth), data)
    def _decode_action(self, action_id):
        """Convert the output of _encode_action() back into a real Action object.
        If the action_id is invalid, raises a TamperingError.
        """
        assert self._curr_page_encoded is not None, "Page state must be known when decoding an action!"
        if "." not in action_id: raise TamperingError("Malformed action_id %s" % action_id)
        auth, data = action_id.split(".", 1)
        if base64.urlsafe_b64decode(auth) != hmac.new(self._secret_key, "%s.%s" % (data, self._curr_page_encoded), hashlib.sha1).digest():
            raise TamperingError("Signature does not match for %s" % action_id)
        action = pickle.loads(zlib.decompress(base64.urlsafe_b64decode(data)))
        return action
    def start(self, request, handler, context=None):
        """No Action provided -- just display the given view.  Used e.g. for the start of a new session."""
        self._set_page(Page(handler, context, None))
        self._encode_page() # needs to be present so view can create actions
        try:
            self._mode = EDWA.MODE_RENDER
            return self._curr_page(request, self)
        finally: self._mode = None
    def run(self, request, action_id, page_id):
        """Run the provided action and display the resulting view."""
        action_id, page_id = str(action_id), str(page_id)
        # Data is saved in two pieces, "base64(hmac).base64(action)" and "base64(page)"
        # However, hmac is computed on "base64(action).base64(page)"
        # Typically, many different actions (small) share the same page data (large).
        self._curr_page_encoded = page_id # don't decode yet, signature not verified
        action = self._decode_action(action_id) # this checks the signature
        self._decode_page() # if no exception, now safe to decode page data
        try:
            self._mode = EDWA.MODE_ACTION
            action(request, self)
        finally: self._mode = None
        self._encode_page() # needs to be present so view can create actions
        try:
            self._mode = EDWA.MODE_RENDER
            return self._curr_page(request, self)
        finally: self._mode = None
    def do_goto(self, handler, context=None):
        """Change the current view, discarding the old view."""
        prev_page = self._curr_page
        self._set_page(Page(handler, context, self._curr_page.parent))
        if hasattr(prev_page, "return_handler"):
            # To avoid having to load/dump the handler function, we just copy it over.
            # TODO: refactor this to be less ugly!
            self._curr_page.return_handler = prev_page.return_handler
            self._curr_page.return_context = prev_page.return_context
    def do_call(self, handler, context=None, return_handler=None, return_context=None):
        """Change the current view, pushing the old view further down the stack.
        If return_handler is provided, it will be called with (edwa_obj, return_value, return_context)
        *immediately* when (and if) the new page returns.
        """
        self._set_page(Page(handler, context, self._curr_page, return_handler, return_context))
    def do_return(self, return_value=None):
        """Discard the current view and pop the previous view from the stack.
        If that view specified a return callback, it will be immediately passed "return_value".
        """
        prev_page = self._curr_page
        self._set_page(self._curr_page.parent)
        prev_page.on_return(self, return_value)
    def make_noop(self):
        """make_action() shortcut to re-display the current view with no changes."""
        return self.make_action(_handle_noop)
    def make_goto(self, handler, context=None):
        """make_action() shortcut to change the current view when clicked."""
        return self.make_action(_handle_goto, _dump_func(handler), context)
    def make_call(self, handler, context=None, return_handler=None, return_context=None):
        """make_action() shortcut to change the current view when clicked."""
        if return_handler: return self.make_action(_handle_call, _dump_func(handler), context, _dump_func(return_handler), return_context)
        else: return self.make_action(_handle_call, _dump_func(handler), context)
    def make_return(self, return_value=None):
        """make_action() shortcut to change the current view when clicked."""
        return self.make_action(_handle_return, return_value)
    def make_action(self, func, *args, **kwargs):
        """Make a URL-safe action "token" that will invoke the given function when token is passed to run()."""
        return self._encode_action(Action(func, args, kwargs))
    def make_page_data(self):
        """Return URL-safe page data token that needs to be passed to run() along with the action token."""
        assert self._curr_page_encoded is not None
        return self._curr_page_encoded
    # Shortcuts for href(make_XXX()):
    def href_noop(self): return self.href(self.make_noop())
    def href_goto(self, *args, **kwargs): return self.href(self.make_goto(*args, **kwargs))
    def href_call(self, *args, **kwargs): return self.href(self.make_call(*args, **kwargs))
    def href_return(self, *args, **kwargs): return self.href(self.make_return(*args, **kwargs))
    def href_action(self, *args, **kwargs): return self.href(self.make_action(*args, **kwargs))
    def href(self, action_id):
        """Convenience function to wrap action_id's in JavaScript href to POST the hidden_form().
        Typical use in Django: <a href='{% eval edwa.href(edwa.make_goto(...)) %}'>link text</a>"""
        if self._use_GET and len(action_id)+len(self._curr_page_encoded) <= self._max_url_length:
            return 'libedwa:%s' % action_id # will be expanded to a full URL by JavaScript
        else:
            return 'javascript:libedwa_post_href("%s");' % action_id # will trigger a POST of a hidden form via JavaScript
    def hidden_form(self):
        """Create a hidden FORM and some JavaScript for an HTML page, to enable the href() helper function.
        Should be placed at the very end of the page, just before </BODY>, after all <A> links!
        """
        return r"""<script type='text/javascript'>
// This part is for links submitted via GET:
re = RegExp("\\blibedwa:");
var anchors = document.getElementsByTagName("A");
for(var i = 0; i < anchors.length; i++) {
  var a = anchors[i];
  a.href = a.href.replace(re, "?%(pkey)s=%(pdata)s&%(akey)s=");
}
// This part is for links submitted via POST:
function libedwa_post_href(action_id) {
  document.getElementById('__libedwa__.action_id').value = action_id; document.getElementById('__libedwa__').submit();
}
</script>
<form id='__libedwa__' action='' method='POST' enctype='multipart/form-data'>
<input type='hidden' name='%(pkey)s' value='%(pdata)s'>
<input type='hidden' id='__libedwa__.action_id' name='%(akey)s' value=''>
</form>
""" % {'pkey':self.PAGE_KEY, 'pdata':self.make_page_data(), 'akey':self.ACTION_KEY}
#        else: return r"""<script type='text/javascript'>function libedwa_post_href(action_id) { document.getElementById('__libedwa__.action_id').value = action_id; document.getElementById('__libedwa__').submit(); }</script>
#<form id='__libedwa__' action='' method='POST' enctype='multipart/form-data'>
#<input type='hidden' name='%s' value='%s'>
#<input type='hidden' id='__libedwa__.action_id' name='%s' value=''>
#</form>
#""" % (self.PAGE_KEY, self.make_page_data(), self.ACTION_KEY)

try:
    import keyczar.keyczar
    class KeyczarEDWA(EDWA):
        def __init__(self, path_to_keys, *args, **kwargs):
            """This version provides excellent security (as far as I know) while still storing all data on the client side.
            Both actions and page states are encrypted, so that clients cannot decode their contents.
            However, it is very, very slow compared to the unencrypted version -- generating 100 links takes several seconds.
            Also, the action IDs (passed in URLs) are ~50% larger, typically 200 - 300 characters."""
            super(KeyczarEDWA, self).__init__("THIS WILL NEVER BE USED", *args, **kwargs)
            del self._secret_key # just to make sure the dummy value is never used
            self.path_to_keys = path_to_keys
            self.crypter = keyczar.keyczar.Crypter.Read(self.path_to_keys)
        def _encode_page(self):
            assert self._curr_page is not None
            self._curr_page_encoded = self.crypter.Encrypt(zlib.compress(pickle.dumps(self._curr_page, pickle.HIGHEST_PROTOCOL), 1)) # also HMAC-SHA1 signed and web-safe base64 encoded
        def _decode_page(self):
            assert self._curr_page_encoded is not None
            self._set_page(pickle.loads(zlib.decompress(self.crypter.Decrypt(self._curr_page_encoded))))
        def _encode_action(self, action):
            assert self._mode is not EDWA.MODE_ACTION, "Can't create new actions during an action, because page state is not finalized."
            assert self._curr_page_encoded is not None, "Page state must be serialized before creating an action!"
            # Although the action will be encrypted and signed,
            # we have to prevent attackers mixing-and-matching actions with page states.
            page_hash = hashlib.sha256(self._curr_page_encoded).digest()
            return self.crypter.Encrypt(zlib.compress(pickle.dumps((action, page_hash), pickle.HIGHEST_PROTOCOL), 1))
        def _decode_action(self, action_id):
            assert self._curr_page_encoded is not None, "Page state must be known when decoding an action!"
            action, page_hash = pickle.loads(zlib.decompress(self.crypter.Decrypt(action_id)))
            if page_hash != hashlib.sha256(self._curr_page_encoded).digest():
                raise TamperingError("Action and page data were mixed-and-matched for %s" % action_id)
            return action
except ImportError:
    pass

def _handle_noop(request, edwa):
    pass
def _handle_goto(request, edwa, handler, context):
    edwa.do_goto(_load_func(handler), context)
def _handle_call(request, edwa, handler, context, return_handler=None, return_context=None):
    if return_handler is not None: return_handler = _load_func(return_handler)
    edwa.do_call(_load_func(handler), context, return_handler, return_context)
def _handle_return(request, edwa, return_value):
    edwa.do_return(return_value)

class Context(dict):
    """A standard dictionary, but one that can be hashed for intern()'ing purposes.
    The hash function is expensive, but I see no other way to avoid choking on nested dictionaries.
    Also features a simple extension which allows dotted access in addition to normal lookup.
    """
    def __hash__(self):
        return hash(pickle.dumps(self))
    def __getattr__(self, name):
        '''Only called when normal lookup fails...'''
        try: return self[name]
        except KeyError: raise AttributeError("No such attribute %s" % name)
    def __setattr__(self, name, value):
        if name in self.__dict__: self.__dict__[name] = value
        else: self[name] = value
    def __delattr__(self, name):
        if name in self.__dict__: del self.__dict__[name]
        else: del self[name]

class Page(object):
    """Wrapper for a view function and its context.
    Pages (and context!) must be immutable once exposed to the web client, or the meaning of URLs could change."""
    def __init__(self, handler, context=None, parent=None, return_handler=None, return_context=None):
        self.handler = _dump_func(handler)
        # In this version, context is NOT inherited from parents:
        if context is None: self.context = Context()
        else:
            if not isinstance(context, Context): context = Context(context)
            self.context = context
        ## In this version, context IS inherited from parents:
        #if parent is not None: self.context = copy.deepcopy(parent.context)
        #else: self.context = Context()
        #if context is not None: self.context.update(context)
        self.parent = parent
        # Return handler will be called by EDWA immediately
        # after calling do_return() when this is the current page.
        if return_handler is not None:
            self.return_handler = _dump_func(return_handler)
            self.return_context = return_context
    def __call__(self, request, edwa):
        handler = _load_func(self.handler)
        return handler(request, edwa)
    def on_return(self, edwa, return_value):
        # edwa.context will be the context of the returned-to page (self.parent.context), not self.context
        if hasattr(self, "return_handler"):
            handler = _load_func(self.return_handler)
            handler(edwa, return_value, self.return_context)
    def __cmp__(self, other):
        return cmp(self.__dict__, other.__dict__)

class Action(object):
    """Wrapper for an action function and its initial state."""
    def __init__(self, handler, args=None, kwargs=None):
        self.handler = _dump_func(handler)
        # By not setting these as empty objects, we can save a little memory when pickled?
        if args: self.args = args
        if kwargs: self.kwargs = kwargs
    def __call__(self, request, edwa):
        handler = _load_func(self.handler)
        args = getattr(self, "args", [])
        kwargs = getattr(self, "kwargs", {})
        return handler(request, edwa, *args, **kwargs)

class ExerciseApi(object):
    """Simple demonstration of the API, without real HTTP requests."""
    def run2(self):
        self.run(KeyczarEDWA, "/home/ian.davis/tmp-pycrypto/crypt_keys")
    def run(self, EdwaClass=EDWA, auth="my-secret-key"):
        def show(action_id):
            print "    Action ID length:", len(action_id) #, action_id
            return action_id
        edwa = EdwaClass(auth)
        edwa.start("<FAKE_REQUEST>", self.page1)
        edwa.run("<FAKE_REQUEST>", show(edwa.make_noop()), edwa.make_page_data())
        edwa.run("<FAKE_REQUEST>", show(edwa.make_action(self.action3)), edwa.make_page_data())
        edwa.run("<FAKE_REQUEST>", show(edwa.make_call(self.page2, return_handler=self.onreturn1)), edwa.make_page_data())
        edwa.run("<FAKE_REQUEST>", show(edwa.make_action(self.action1)), edwa.make_page_data())
        edwa.run("<FAKE_REQUEST>", show(edwa.make_goto(self.page3)), edwa.make_page_data())
        for i in xrange(100): edwa.make_goto(self.page4)
        edwa.run("<FAKE_REQUEST>", show(edwa.make_action(self.action1)), edwa.make_page_data())
        edwa.run("<FAKE_REQUEST>", show(edwa.make_action(self.action2)), edwa.make_page_data()) # this does a call()
        edwa.run("<FAKE_REQUEST>", show(edwa.make_return()), edwa.make_page_data())
        edwa.run("<FAKE_REQUEST>", show(edwa.make_return("HIMOM!")), edwa.make_page_data())
        edwa.run("<FAKE_REQUEST>", show(edwa.make_action(self.action1)), edwa.make_page_data())
        print "Suspending..."
        action_id = edwa.make_noop() # save current state
        page_data = edwa.make_page_data()
        print "Re-animating..."
        edwa = EdwaClass(auth) # clean object
        edwa.run("<FAKE_REQUEST>", action_id, page_data) # restore state (current view, etc)
        ## This makes encoding expensive (~ 1 sec), b/c it adds 100 large Action objects to be interned.
        for i in xrange(100): edwa.make_goto(self.page4)
        return edwa
    def page1(self, request, edwa):
        print "On page 1.  Request=%s.  Context=%s." % (request, edwa.context.keys())
    def page2(self, request, edwa):
        print "On page 2.  Request=%s.  Context=%s." % (request, edwa.context.keys())
    def page3(self, request, edwa):
        print "On page 3.  Request=%s.  Context=%s." % (request, edwa.context.keys())
    def page4(self, request, edwa):
        print "On page 4.  Request=%s.  Context=%s." % (request, edwa.context.keys())
    def action1(self, request, edwa):
        print "  Entering action 1.  Request=%s.  Context=%s." % (request, edwa.context.keys())
        edwa.context['foo'] = 'bar'
        edwa.context['big'] = list(range(10000))
        print "  Exiting action 1.  Request=%s.  Context=%s." % (request, edwa.context.keys())
    def action2(self, request, edwa):
        print "  Entering action 2.  Request=%s.  Context=%s." % (request, edwa.context.keys())
        edwa.do_call(self.page4, {"fizz":"buzz"}, self.onreturn1, "EXTRA-STUFF")
        print "  Exiting action 2.  Request=%s.  Context=%s." % (request, edwa.context.keys())
    def action3(self, request, edwa):
        print "  Entering action 3.  Request=%s.  Context=%s." % (request, edwa.context.keys())
        edwa.context['name'] = 'John Q. Public'
        edwa.context['address'] = '123 Main St, Ste 456'
        edwa.context['city'] = 'Couldabeenanywhere'
        edwa.context['state'] = 'Alaska'
        edwa.context['zip'] = '12345-6789'
        edwa.context['phone_home'] = '555-987-6543'
        print "  Exiting action 3.  Request=%s.  Context=%s." % (request, edwa.context.keys())
    def onreturn1(self, edwa, return_value, return_context):
        print "Return value %s in context %s" % (return_value, return_context)
